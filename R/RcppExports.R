# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sampler
#'
#' @export
MCMC_Sampler_c <- function(N__jk, n__j, r, niter, nburn, thin, option) {
    .Call(`_HSSM_MCMC_Sampler_c`, N__jk, n__j, r, niter, nburn, thin, option)
}

#' 
NULL

#' Raising Factorial
#'
#' \loadmathjax This function computes the rising factorial \mjseqn{(a)^{n}} using the gsl code for the Pochhammer symbol, i.e
#' \mjsdeqn{(a)^{n} = \frac{\Gamma(a+n)}{\Gamma(a)}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
raising_factorial <- function(n, a) {
    .Call(`_HSSM_raising_factorial`, n, a)
}

#' log Raising Factorial
#'
#' \loadmathjax This function computes the logarithm of the rising factorial \mjseqn{(a)^{n}} using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{raising_factorial}} and \code{\link{compute_Pochhammer}} for details.
#' @export
log_raising_factorial <- function(n, a) {
    .Call(`_HSSM_log_raising_factorial`, n, a)
}

#' Falling Factorial
#'
#' \loadmathjax This function computes the falling factorial \mjseqn{ a_{n} }. See \code{\link{raising_factorial}} for details.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
my_falling_factorial <- function(n, a) {
    .Call(`_HSSM_my_falling_factorial`, n, a)
}

#' log Falling Factorial
#'
#' \loadmathjax This function computes the logarithm of the falling factorial \mjseqn{ a_{n} } using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{my_falling_factorial}} and \code{\link{compute_Pochhammer}} for details.
#' @export
my_log_falling_factorial <- function(n, a) {
    .Call(`_HSSM_my_log_falling_factorial`, n, a)
}

#' Pochhammer Symbol
#'
#' \loadmathjax This function computes the Pochhammer symbol,
#' \mjsdeqn{(a)^{x} = \frac{\Gamma(a+x)}{\Gamma(a)}}.
#' Where \code{x} is a real number. When x is an integer, such a function coincides with the rising factorial defined in \code{\link{raising_factorial}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
compute_Pochhammer <- function(x, a) {
    .Call(`_HSSM_compute_Pochhammer`, x, a)
}

#' Pochhammer log Symbol
#'
#' \loadmathjax This function computes the Pochhammer symbol in log form. See \code{\link{compute_Pochhammer}} for details.
#' @export
compute_log_Pochhammer <- function(x, a) {
    .Call(`_HSSM_compute_log_Pochhammer`, x, a)
}

#' Zeta Riemann function in log scale
#'
#' @export
log_zeta_Riemann <- function(s) {
    .Call(`_HSSM_log_zeta_Riemann`, s)
}

#' compute_logC - Compute log of absolute values of non Central C number
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{log(|C(n,k; scale, location)|)} for each k=0,...,n.
#' This implementation uses Rcpp vectors.
#' @param scale must be strictly negative.
#' @param locatio must be non positive. Set to 0 for central C numbers.
#' @export
compute_logC <- function(n, scale, location) {
    .Call(`_HSSM_compute_logC`, n, scale, location)
}

#' All terms of V
#'
#' This function returns the log of all terms in V, from m=0 up to M_max
#' @export
log_Vprior_long <- function(k, n_i, gamma, prior, prior_param, M_max) {
    .Call(`_HSSM_log_Vprior_long`, k, n_i, gamma, prior, prior_param, M_max)
}

#' V approximation - Zeta Riemann
#'
#' Non usare questa funzione. Non ci sono funzioni che implementino il log della zeta-Riemann. Quindi ho problemi numerici e non va
#' @export
log_Vprior_apprx1 <- function(k, n_i, tol, gamma, prior, prior_param, M_max) {
    .Call(`_HSSM_log_Vprior_apprx1`, k, n_i, tol, gamma, prior, prior_param, M_max)
}

#' V approximation - Under threshold
#'
#' This approximation has no theoretical guarantees
#' @export
log_Vprior_apprx2 <- function(k, n_i, tol, gamma, prior, prior_param, M_max) {
    .Call(`_HSSM_log_Vprior_apprx2`, k, n_i, tol, gamma, prior, prior_param, M_max)
}

#' V approximation - Compute Upper tail
#'
#' Non posso calcolare direttamente il log di P(M>N+K). Usala solo se gamma è molto piccolo o n_j è molto grande.
#' @export
log_Vprior_apprx3 <- function(k, n_i, tol, gamma, prior, prior_param, M_max) {
    .Call(`_HSSM_log_Vprior_apprx3`, k, n_i, tol, gamma, prior, prior_param, M_max)
}

#' log qM - Posterior evaluation
#'
#' @export
log_qM_post <- function(m, prior, prior_param, k, n_j, gamma_j, log_V, M_max) {
    .Call(`_HSSM_log_qM_post`, m, prior, prior_param, k, n_j, gamma_j, log_V, M_max)
}

#' 
p_distinct_prior_c <- function(k, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_p_distinct_prior_c`, k, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
p_shared_prior_c <- function(s, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_p_shared_prior_c`, s, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
p_joint_prior_c <- function(k, s, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_p_joint_prior_c`, k, s, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
p_distinct_posterior_c <- function(r, k, m_j, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_p_distinct_posterior_c`, r, k, m_j, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
p_shared_posterior_c <- function(t, k, m_j, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_p_shared_posterior_c`, t, k, m_j, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
Expected_prior_c <- function(n_j, gamma_j, type, prior, prior_param, M_max, tol) {
    .Call(`_HSSM_Expected_prior_c`, n_j, gamma_j, type, prior, prior_param, M_max, tol)
}

#' 
Expected_posterior_c <- function(k, m_j, n_j, gamma_j, type, prior, prior_param, M_max, tol) {
    .Call(`_HSSM_Expected_posterior_c`, k, m_j, n_j, gamma_j, type, prior, prior_param, M_max, tol)
}

#' 
Sums_logC <- function(n_j, gamma_j) {
    .Call(`_HSSM_Sums_logC`, n_j, gamma_j)
}

#' 
UpperBounds_c <- function(n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_UpperBounds_c`, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
LowerBounds_c <- function(n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_HSSM_LowerBounds_c`, n_j, gamma_j, prior, prior_param, M_max)
}

#' 
D_distinct_prior_c <- function(n_j, gamma_j, prior, prior_param, M_max, Kstart, logV_vec) {
    .Call(`_HSSM_D_distinct_prior_c`, n_j, gamma_j, prior, prior_param, M_max, Kstart, logV_vec)
}

#' 
#' Compute the distribution for the prior number of distinct components in a given interval. Hence, in general, the returned values may not sum up to 1 
D_distinct_prior_interval_c <- function(n_j, gamma_j, prior, prior_param, M_max, Kmin, Kmax, logV_vec, print) {
    .Call(`_HSSM_D_distinct_prior_interval_c`, n_j, gamma_j, prior, prior_param, M_max, Kmin, Kmax, logV_vec, print)
}

#' 
D_joint_prior_c <- function(n_j, gamma_j, prior, prior_param, M_max, Kstart, logV_vec) {
    .Call(`_HSSM_D_joint_prior_c`, n_j, gamma_j, prior, prior_param, M_max, Kstart, logV_vec)
}

#' 
#' Compute the joint prior distribution in a given square. Hence, in general, the returned values may not sum up to 1 
D_joint_prior_square_c <- function(n_j, gamma_j, prior, prior_param, M_max, Kmin, Kmax, Smin, Smax, logV_vec, print) {
    .Call(`_HSSM_D_joint_prior_square_c`, n_j, gamma_j, prior, prior_param, M_max, Kmin, Kmax, Smin, Smax, logV_vec, print)
}

#' 
Distinct_Prior_MCMC_c <- function(N, N_k, rho0, K0, Niter, n_j, gamma_j, prior, prior_param, M_max, seed) {
    .Call(`_HSSM_Distinct_Prior_MCMC_c`, N, N_k, rho0, K0, Niter, n_j, gamma_j, prior, prior_param, M_max, seed)
}

#' 
#' Compute the distinct posterior distribution in a given interval. Hence, in general, the returned values may not sum up to 1 
D_distinct_post_interval_c <- function(m_j, gamma_j, n_j, k, prior, prior_param, M_max, Kmin, Kmax, logVpost_vec, print) {
    .Call(`_HSSM_D_distinct_post_interval_c`, m_j, gamma_j, n_j, k, prior, prior_param, M_max, Kmin, Kmax, logVpost_vec, print)
}

#' 
#' Compute the joint posterior distribution in a given square. Hence, in general, the returned values may not sum up to 1 
D_joint_post_square_c <- function(m_j, gamma_j, n_j, k, prior, prior_param, M_max, Kmin, Kmax, Smin, Smax, logVpost_vec, print) {
    .Call(`_HSSM_D_joint_post_square_c`, m_j, gamma_j, n_j, k, prior, prior_param, M_max, Kmin, Kmax, Smin, Smax, logVpost_vec, print)
}

#' 
#' Compute the distinct posterior distribution in a given interval. Hence, in general, the returned values may not sum up to 1 
D_jointKS_post_largen_c <- function(k, m_j, n_j, gamma_j, prior, prior_param, Kmin, Kmax, Smin, Smax, log_V, M_max) {
    .Call(`_HSSM_D_jointKS_post_largen_c`, k, m_j, n_j, gamma_j, prior, prior_param, Kmin, Kmax, Smin, Smax, log_V, M_max)
}

#' 
#' Compute the marginal predictive posterior distribution of the number of shared species in a single point named t
p_shared_post_largen_c <- function(t, k, m_j, n_j, gamma_j, prior, prior_param, log_V, M_max) {
    .Call(`_HSSM_p_shared_post_largen_c`, t, k, m_j, n_j, gamma_j, prior, prior_param, log_V, M_max)
}

#' Test ComponentPrior
#' @export
Test_Prior <- function() {
    invisible(.Call(`_HSSM_Test_Prior`))
}

#' Test prod_sum
#' @export
Test_prod_sum <- function() {
    invisible(.Call(`_HSSM_Test_prod_sum`))
}

